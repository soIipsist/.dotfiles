export VM_DIR="/var/lib/libvirt/images"

alias vm_list="sudo virsh list --all"
alias vm_destroy="sudo virsh destroy"
alias vm_stop="sudo virsh destroy"
alias vm_start="sudo virsh start"
alias vm_console="sudo virsh console"
alias vm_edit="sudo virsh edit"

vm_update() {
    local vm="$1"
    local source_xml="${2:-/var/lib/libvirt/images/$vm/$vm.xml}"
    local dest_xml="/etc/libvirt/qemu/$vm.xml"

    if [ ! -f "$source_xml" ]; then
        echo "No xml specified."
        return 0
    fi
    sudo virsh undefine --keep-nvram "$vm"
    sudo cp "$source_xml" "$dest_xml"
    sudo virsh define "$dest_xml"
}

vm_reset() {
    local vms=("$@")
    local vm

    if ((${#vms[@]} == 0)); then
        echo "No VMs specified."
        return 0
    fi

    echo "Processing: ${vms[*]}"
    echo

    for vm in "${vms[@]}"; do
        if [ ! -d "$VM_DIR/$vm" ]; then
            echo "VM '$vm' does not exist → skipping"
            continue
        fi

        printf '  • %-20s ' "$vm"
        sudo virsh destroy "$vm" &>/dev/null && echo -n "stopped "
        # remove .qcow2 image
        IMG_DEST="/var/lib/libvirt/images/${vm}.qcow2"
        echo "removed $IMG_DEST"
        sudo rm "$IMG_DEST"
        if sudo virsh undefine "$vm" --remove-all-storage --nvram &>/dev/null; then
            echo "removed"
        else
            echo "already gone"
        fi
    done

    echo
    echo "Done."
}

generate_iso_image() {
    CLOUD_DIR="$1"
    USER_DATA="$2"
    META_DATA="$3"
    SSH_KEY="$4"
    CLOUD_ISO="${CLOUD_DIR}/cidata.iso"

    [ -d "$CLOUD_DIR" ] || {
        echo "Error: directory $CLOUD_DIR not found"
        return 1
    }
    [ -f "$USER_DATA" ] || {
        echo "Error: user-data file missing: $USER_DATA"
        return 1
    }
    [ -f "$META_DATA" ] || {
        echo "Error: meta-data file missing: $META_DATA"
        return 1
    }

    echo "Using cloud-init"
    sudo cp "$USER_DATA" "${CLOUD_DIR}/user-data"
    sudo cp "$META_DATA" "${CLOUD_DIR}/meta-data"

    if [ -n "$SSH_KEY" ]; then
        echo "Updating SSH key in user-data"
        sudo sed -i "/ssh_authorized_keys:/,/^[^ ]/c\    ssh_authorized_keys:\n      - $SSH_KEY" \
            "${CLOUD_DIR}/user-data"
    fi
    sudo genisoimage -output "$CLOUD_ISO" -volid cidata -joliet -rock \
        "${CLOUD_DIR}/user-data" "${CLOUD_DIR}/meta-data"
}

get_raw_image() {
    local IMAGE="$1"
    local IMAGE_DEST="$2"

    if [ -z "$IMAGE" ]; then
        echo "No raw images provided."
        return 1
    fi

    # download image from url, if provided
    if [[ "$IMAGE" =~ ^https?:// ]]; then
        echo "Downloading image from URL..."
        filename=$(basename "$IMAGE")
        tmp=$(sudo mktemp --suffix="$filename")
        sudo wget -q --show-progress -O "$tmp" "$IMAGE"
        IMAGE="$tmp"
    fi

    echo "Raw image conversion: $IMAGE -> $IMAGE_DEST"

    case "$IMAGE" in
    *cloudimg*.img | *-server-cloudimg-*.img)
        echo "Cloud image detected → do NOT convert."
        sudo cp "$IMAGE" "$IMAGE_DEST"
        return
        ;;
    *.raw)
        echo "Converting raw .raw → qcow2..."
        sudo qemu-img convert -f raw -O qcow2 "$IMAGE" "$IMAGE_DEST"
        ;;
    *.tar.xz | *.tar.gz | *.tgz)
        echo "Extracting tar archive → converting first .img or .raw to qcow2..."
        tmp_dir=$(sudo mktemp -d)
        sudo tar -xf "$IMAGE" -C "$tmp_dir"
        img_file=$(sudo find "$tmp_dir" -type f \( -name "*.img" -o -name "*.raw" \) | head -n 1)
        [ -z "$img_file" ] && {
            echo "No .img or .raw file found in archive"
            sudo rm -rf "$tmp_dir"
            return 1
        }

        if [[ "$img_file" == *.qcow2 ]]; then
            echo "Archive contains qcow2 → copying"
            sudo mv "$img_file" "$IMAGE_DEST"
        else
            echo "Converting extracted image to qcow2"
            sudo qemu-img convert -f raw -O qcow2 "$img_file" "$IMAGE_DEST"
        fi
        sudo rm -rf "$tmp_dir"
        ;;
    *.xz | *.img.xz)
        echo "Decompressing .xz → converting to qcow2..."
        tmp_img=$(sudo mktemp --suffix=.img)
        sudo unxz -c "$IMAGE" | sudo tee "$tmp_img" >/dev/null
        sudo qemu-img convert -f raw -O qcow2 "$tmp_img" "$IMAGE_DEST"
        sudo rm -f "$tmp_img"
        ;;
    *.img)
        echo "Converting raw .img → qcow2..."
        sudo qemu-img convert -f raw -O qcow2 "$IMAGE" "$IMAGE_DEST"
        ;;
    *.qcow2)
        echo "Using existing qcow2..."
        sudo mv "$IMAGE" "$IMAGE_DEST"
        ;;
    *)
        echo "Copying image as-is..."
        sudo mv "$IMAGE" "$IMAGE_DEST"
        ;;
    esac

    if [ -n "$tmp" ]; then
        sudo rm "$tmp"
    fi
}

vm_init() {
    # Default parameters
    NAME="ubuntu_vm"
    MEMORY=3072
    VCPUS=4
    DISK_SIZE=80
    IMAGE="" # QCOW2 or raw
    ISO=""   # Boot ISO (Windows or Linux installer)
    XML=""
    OS="detect=on"
    USER_DATA=""
    META_DATA=""
    CLEAN=1
    USE_GRAPHICS=0
    SSH_KEY=""
    WAIT_FOR_IP=0
    CLOUD_DISK=()
    GRAPHICS=()

    # image links:
    # "https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-amd64.img"

    # Parse args: --name foo --image path ... etc
    while [ $# -gt 0 ]; do
        case "$1" in
        --name)
            NAME="$2"
            shift
            ;;
        --xml)
            XML="$2"
            shift
            ;;
        --memory)
            MEMORY="$2"
            shift
            ;;
        --vcpus)
            VCPUS="$2"
            shift
            ;;
        --disk-size)
            DISK_SIZE="$2"
            shift
            ;;
        --image)
            IMAGE="$2"
            shift
            ;;
        --iso)
            ISO="$2"
            shift
            ;;
        --graphics)
            USE_GRAPHICS="$2"
            shift
            ;;
        --ssh-key)
            SSH_KEY="$2"
            shift
            ;;
        --ip-wait)
            WAIT_FOR_IP="$2"
            shift
            ;;
        --clean)
            CLEAN="$2"
            shift
            ;;
        --os)
            OS="$2"
            shift
            ;;
        *)
            echo "Unknown arg: $1"
            return 1
            ;;
        esac
        shift
    done

    if [ -z "$NAME" ] && [ -z "$XML" ]; then
        echo "ERROR: You must provide --name or --xml"
        return 1
    fi

    IMG_DEST="/var/lib/libvirt/images/${NAME}.qcow2"
    CLOUD_DIR="/var/lib/libvirt/images/${NAME}"

    # Determine USER_DATA and META_DATA from vm name
    if [ -n "$VM_DIR" ]; then
        VM_METADATA_DIR="$VM_DIR/$NAME"
        for file in "$VM_METADATA_DIR"/*; do
            if [[ "$file" == *.iso && -z "$ISO" ]]; then
                ISO="$file"
                echo "Setting iso file to $ISO."
            fi

            if [[ "$file" == *.xml && -z "$XML" ]]; then
                XML="$file"
                echo "Setting xml file to $XML."
            fi

            if [[ "$(basename "$file")" == "user-data" ]]; then
                USER_DATA="$file"
                echo "Setting user-data file to $USER_DATA."
            fi

            if [[ "$(basename "$file")" == "meta-data" ]]; then
                META_DATA="$file"
                echo "Setting meta-data file to $META_DATA."
            fi
        done
    fi

    if [ -z "$IMAGE" ] && [ -z "$ISO" ]; then
        echo "ERROR: You must provide --image or --iso"
        return 1
    fi

    if [ "$CLEAN" = 1 ]; then
        sudo virsh destroy "$NAME" 2>/dev/null || true
        sudo virsh undefine "$NAME" --remove-all-storage 2>/dev/null || true
    fi

    sudo mkdir -p "$CLOUD_DIR"
    get_raw_image "$IMAGE" "$IMG_DEST"

    # Create cloud-init ISO if provided
    if [ -n "$USER_DATA" ] && [ -n "$META_DATA" ]; then
        generate_iso_image "$CLOUD_DIR" "$USER_DATA" "$META_DATA" "$SSH_KEY"
        CLOUD_DISK=(--disk $CLOUD_ISO,device=cdrom --import)
    fi

    if [ "$USE_GRAPHICS" = 1 ]; then
        GRAPHICS=(--graphics vnc,listen=0.0.0.0)
    else
        GRAPHICS=(--graphics none)
    fi

    if [ -n "$XML" ]; then
        sudo virsh define "$XML"
        echo "Defining from XML $XML."
    else
        if [ -n "$ISO" ]; then
            # Classic ISO installation
            echo "Performing ISO installation."

            sudo virt-install \
                --name "$NAME" \
                --memory "$MEMORY" \
                --vcpus "$VCPUS" \
                --disk path="$IMG_DEST",format=qcow2,bus=virtio,size="$DISK_SIZE" \
                --cdrom "$ISO" \
                --boot cdrom,hd \
                --network network=default,model=virtio "${GRAPHICS[@]}" \
                --os-variant $OS \
                --noautoconsole
        else
            echo "Performing cloud image installation."

            # Cloud image import
            sudo virt-install \
                --name "$NAME" \
                --memory "$MEMORY" \
                --vcpus "$VCPUS" \
                --import \
                --disk path="$IMG_DEST",format=qcow2,bus=virtio \
                "${CLOUD_DISK[@]}" \
                --boot hd \
                --network network=default,model=virtio \
                "${GRAPHICS[@]}" \
                --os-variant $OS \
                --noautoconsole
        fi
    fi

    echo "VM launched."

    if [ "$USE_GRAPHICS" = 1 ]; then
        echo "To access UI via VNC:"
        echo " ssh -L 5900:127.0.0.1:5900 user@<host>"
        echo " vncviewer 127.0.0.1:5900"
    else
        echo "Headless mode. Use: sudo virsh console $NAME"
    fi

    if [ "$WAIT_FOR_IP" = 0 ]; then
        return 1
    fi

    MAC=$(sudo virsh dumpxml "$NAME" | grep -o "mac address='[^']*" | cut -d"'" -f2 | tr '[:upper:]' '[:lower:]')
    echo "MAC address: $MAC"
    echo "Waiting for IP (max 90 s)..."

    for i in $(seq 1 90); do
        IP=$(arp -an | grep -i "$MAC" | awk '{print $2}' | tr -d '()' || true)
        [ -n "$IP" ] && break
        sleep 1
    done

    if [ -z "$IP" ]; then
        echo "ERROR: No IP after 90 s"
        echo "Debug:"
        sudo virsh domblklist "$NAME"
        echo "Try: sudo virsh console $NAME  (Ctrl+] to exit)"
        return 1
    fi

    echo "IP found: $IP"
    echo "SSH command: ssh user@$IP"
}
