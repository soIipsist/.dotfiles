export DUMPS_DIR="$HOME/.dumps"

ssh_dump() {
    local interface="${1:-any}"
    local dumps_filename="${2:-ssh_dump.pcap}"
    local outfile_path="$DUMPS_DIR/$dumps_filename"

    mkdir -p "$DUMPS_DIR"

    sudo tcpdump -i "$interface" -w "$outfile_path" -v '(tcp port 22 or tcp port 2222) and tcp[tcpflags] & tcp-syn != 0'
}

detect_bruteforce() {
    local SAMPLE_LINES=5
    while [[ $# -gt 0 ]]; do
        case "$1" in
        --lines)
            SAMPLE_LINES="$2"
            shift 2
            ;;
        *)
            echo "Unknown arg: $1"
            return 2
            ;;
        esac
    done

    local LOGSRC=""
    if [[ -r /var/log/auth.log ]]; then
        LOGSRC="/var/log/auth.log"
    else
        # fallback: use journalctl for sshd/syslog messages
        LOGSRC="$(mktemp)"
        # collect relevant journalctl lines (requires root)
        journalctl -o short-iso -u ssh -u sshd --since "1970-01-01" 2>/dev/null >"$LOGSRC" || journalctl -o short-iso --since "1970-01-01" 2>/dev/null >"$LOGSRC"
    fi

    # Patterns that commonly indicate failed attempts / brute force
    local PATTERN='failed password|invalid user|authentication failure|pam:|invalid login|connection reset|did not receive identification|refused connect|authentication error|illegal user'

    local RAW="$(mktemp)"
    local PARSED="$(mktemp)"

    # Extract lines of interest
    if [[ -f "$LOGSRC" ]]; then
        grep -Ei "$PATTERN" "$LOGSRC" >"$RAW" 2>/dev/null || true
    else
        echo "No log source available." >&2
        return 1
    fi

    if [[ ! -s "$RAW" ]]; then
        echo "No failed-auth lines found in $LOGSRC."
        rm -f "$RAW" "$PARSED"
        [[ -f "$LOGSRC" && "$LOGSRC" == /tmp/* ]] && rm -f "$LOGSRC"
        return 0
    fi

    # Normalize timestamps and extract IP, user, and raw line.
    # Supports syslog "Mmm dd HH:MM:SS" and ISO timestamps from journalctl.
    #
    # Output fields: epoch|human_ts|ip|user|rawline
    awk -v year="$(date +%Y)" '
    function to_epoch_syslog(mmm, dd, hm,    months, monthnum, ts) {
      months["Jan"]=1;months["Feb"]=2;months["Mar"]=3;months["Apr"]=4;
      months["May"]=5;months["Jun"]=6;months["Jul"]=7;months["Aug"]=8;
      months["Sep"]=9;months["Oct"]=10;months["Nov"]=11;months["Dec"]=12;
      monthnum = months[mmm];
      # hm is HH:MM:SS or HH:MM
      cmd = sprintf("date -d \"%d-%02d-%02d %s\" +%%s", year, monthnum, dd, hm)
      cmd | getline ts
      close(cmd)
      return ts
    }
    BEGIN {
      YEAR = year
      ip_re = "([0-9]{1,3}\\.){3}[0-9]{1,3}"
    }
    {
      line = $0
      # Try to detect ISO-like timestamp (journalctl -o short-iso)
      if ($1 ~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) {
        # e.g. 2025-10-31T12:34:56...
        ts = $1 " " $2
        cmd = "date -d \"" ts "\" +%s"
        cmd | getline epoch
        close(cmd)
        human = ts
      } else if ($1 ~ /^(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)$/) {
        # syslog style: "Oct 31 12:34:56"
        mmm = $1; dd=$2; hm=$3
        epoch = to_epoch_syslog(mmm, dd, hm)
        human = sprintf("%s %s %s", mmm, dd, hm)
      } else {
        # fallback: use current time
        epoch = systime()
        human = strftime("%Y-%m-%d %H:%M:%S", epoch)
      }

      # attempt to find IPv4 in the line
      ip = ""
      if (match(line, ip_re)) {
        ip = substr(line, RSTART, RLENGTH)
      }

      # attempt to extract a username token if present (common patterns)
      user = "-"
      # "Failed password for invalid user <user> from <ip>"
      if (match(line, /for invalid user[[:space:]]+[^[:space:]]+/)) {
        sub(/.*for invalid user[[:space:]]+/, "", t = substr(line, RSTART))
        split(t, a, /[[:space:]]+/)
        user = a[1]
      } else if (match(line, /for[[:space:]]+[^[:space:]]+/)) {
        sub(/.*for[[:space:]]+/, "", t = substr(line, RSTART))
        split(t, a, /[[:space:]]+/)
        user = a[1]
      }

      if (ip != "") {
        printf("%s|%s|%s|%s|%s\n", epoch, human, ip, user, line)
      } else {
        # keep lines without IP (so they can be reviewed)
        printf("%s|%s|%s|%s|%s\n", epoch, human, "-", user, line)
      }
    }
  ' "$RAW" >"$PARSED"

    echo
    printf "%-18s %8s %20s %20s %12s\n" "IP" "ATTEMPTS" "FIRST_SEEN" "LAST_SEEN" "USERS"
    echo "----------------------------------------------------------------------------------------------------------------"

    awk -F'|' -v sample="$SAMPLE_LINES" '
    {
      epoch=$1; human=$2; ip=$3; user=$4; raw=$5
      if (ip == "-") {
        nodip_count++
        nodip_lines[nodip_count]=$0
        next
      }
      cnt[ip]++
      if (!(ip in first) || epoch < first[ip]) { first[ip]=epoch; first_h[ip]=human }
      if (!(ip in last) || epoch > last[ip]) { last[ip]=epoch; last_h[ip]=human }
      if (user != "-") users[ip][user]=1
      # store sample lines per IP
      if (samples_count[ip] < sample) {
        samples[ip][++samples_count[ip]] = raw
      }
    }
    END {
      PROCINFO["sorted_in"] = "@val_num_desc"  # sort by count desc (GNU awk)
      for (ip in cnt) {
        # build user list
        ulist = ""
        for (u in users[ip]) {
          if (ulist=="") ulist=u; else ulist=ulist "," u
        }
        # print: IP, count, first human, last human, users
        printf("%-18s %8d %20s %20s %12s\n", ip, cnt[ip], first_h[ip], last_h[ip], (ulist==""?"-":ulist))
      }

      # Print "no-ip" lines if any
      if (nodip_count>0) {
        print "\nLines without IPs (examine manually):"
        for (i=1;i<=nodip_count;i++) {
          print substr(nodip_lines[i], index(nodip_lines[i], "|")+1)   # print human + rest
        }
      }

      # print sample lines for each IP
      print "\nSample lines (per IP):"
      for (ip in samples) {
        print "\n--- " ip " ---"
        for (i=1;i<=samples_count[ip];i++) {
          print samples[ip][i]
        }
      }
    }
  ' "$PARSED"

    # cleanup
    rm -f "$RAW" "$PARSED"
    if [[ -f "$LOGSRC" && "$LOGSRC" == /tmp/* ]]; then rm -f "$LOGSRC"; fi
}
