export TCPDUMP_DIR="$HOME/.tcpdump"
export UID="${UID:-$(id -u 2>/dev/null || echo 1000)}"
export REPORT_DIR="/tmp/$UID/reports"

ssh_dump() {
    local interface="${1:-any}"
    local dumps_filename="${2:-ssh_dump.pcap}"
    local outfile_path="$TCPDUMP_DIR/$dumps_filename"
    mkdir -p "$TCPDUMP_DIR"
    sudo tcpdump -i "$interface" -w "$outfile_path" -v '(tcp port 22 or tcp port 2222) and tcp[tcpflags] & tcp-syn != 0'
}

report_bruteforce() {
    local SAMPLE="${1:-5}"
    local TOPN="${2:-50}"
    local LOG="/var/log/auth.log"
    local REPORT_FILE="$REPORT_DIR/bruteforce_report_$(date -u '+%Y-%m-%dT%H-%M-%SZ').log"
    local PATTERN='failed password|invalid user|authentication failure|pam:|invalid login|connection reset|did not receive identification|refused connect|authentication error|illegal user'
    local ip_re='([0-9]{1,3}\.){3}[0-9]{1,3}'

    mkdir -p "$REPORT_DIR"

    # temp files
    local tmp counts
    tmp="$(mktemp)" || {
        echo "mktemp failed"
        return 1
    }
    counts="$(mktemp)" || {
        rm -f "$tmp"
        echo "mktemp failed"
        return 1
    }

    # cleanup when function exits
    trap 'rm -f "$tmp" "$counts"' EXIT

    if [[ ! -r "$LOG" ]]; then
        echo "Cannot read $LOG. Run as root (sudo) or check file path." >&2
        return 1
    fi

    # collect matching lines (case-insensitive)
    grep -Ei "$PATTERN" "$LOG" >"$tmp" 2>/dev/null || true
    if [[ ! -s "$tmp" ]]; then
        echo "No matching failed-auth lines found in $LOG."
        return 0
    fi

    # produce sorted ip counts: "count ip"
    grep -Eo "$ip_re" "$tmp" | sort | uniq -c | sort -nr >"$counts"

    # report header
    {
        printf "BRUTE-FORCE / FAILED-AUTH SUMMARY\n"
        printf "Log: %s\nReport generated: %s\n\n" "$LOG" "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        printf "%-17s %8s  %-20s  %-20s  %s\n" "IP" "ATTEMPTS" "FIRST_LINE" "LAST_LINE" "USERS"
        printf "%s\n" "----------------------------------------------------------------------------------------------------------------"
    } >"$REPORT_FILE"

    # print table rows (shell loop for portability)
    local line ip count printed=0 first_line last_line users f l
    while read -r count ip; do
        printed=$((printed + 1))
        if ((printed > TOPN)); then break; fi

        first_line="$(grep -F -- "$ip" "$tmp" | head -n1 || true)"
        last_line="$(grep -F -- "$ip" "$tmp" | tail -n1 || true)"

        # extract candidate usernames: look for 'for invalid user <user>' or 'for <user>'
        users="$(grep -F -- "$ip" "$tmp" |
            awk '{
          for(i=1;i<=NF;i++){
            if (tolower($i)=="for" && (i+1)<=NF) print $(i+1)
            if (tolower($i)=="user" && (i+1)<=NF) print $(i+1)
          }
        }' |
            sed 's/[:,;]$//' |
            sort -u |
            paste -s -d, - 2>/dev/null || true)"

        if [[ -z "$users" ]]; then users="-"; fi

        # truncate first/last for table clarity (20 chars)
        if [[ ${#first_line} -gt 20 ]]; then f="${first_line:0:17}..."; else f="$first_line"; fi
        if [[ ${#last_line} -gt 20 ]]; then l="${last_line:0:17}..."; else l="$last_line"; fi

        printf "%-17s %8s  %-20s  %-20s  %s\n" "$ip" "$count" "$f" "$l" "$users" >>"$REPORT_FILE"
    done <"$counts"

    # lines without IPv4
    local noip_count
    noip_count=$(grep -Eiv "$ip_re" "$tmp" | wc -l | tr -d '[:space:]')
    if [[ "$noip_count" -gt 0 ]]; then
        printf "\n%-17s %8s  %s\n" "NO_IP" "$noip_count" "(lines without an IPv4 address)" >>"$REPORT_FILE"
    fi

    # sample lines header
    {
        printf "\n\nSAMPLE LINES (up to %d per IP) — top IPs first\n" "$SAMPLE"
        printf "%s\n" "--------------------------------------------------------------------"
    } >>"$REPORT_FILE"

    # append sample lines for top IPs
    printed=0
    while read -r _ ip; do
        printed=$((printed + 1))
        if ((printed > TOPN)); then break; fi
        printf "\n--- %s ---\n" "$ip" >>"$REPORT_FILE"
        grep -F -- "$ip" "$tmp" | head -n "$SAMPLE" >>"$REPORT_FILE"
    done <"$counts"

    # include some NO_IP lines if present
    if [[ "$noip_count" -gt 0 ]]; then

        printf "\n\n--- LINES WITHOUT AN IPv4 (first 30 shown) ---\n" >>"$REPORT_FILE"
        grep -Eiv "$ip_re" "$tmp" | head -n 30 >>"$REPORT_FILE"
    fi
    echo "Report saved to: $REPORT_FILE"
}

report_fail2ban() {
    local REPORT_FILE
    local TMP_CURR

    mkdir -p "$REPORT_DIR"
    REPORT_FILE="$REPORT_DIR/fail2ban_report_$(date -u '+%Y-%m-%dT%H-%M-%SZ').log"
    IP_REPORT_FILE="$REPORT_DIR/fail2ban_ip_report_$(date -u '+%Y-%m-%dT%H-%M-%SZ').log"

    # temp files
    TMP_CURR="$(mktemp)" || return 1
    trap 'rm -f "$TMP_CURR"' EXIT

    # report header
    printf "FAIL2BAN REPORT\nGenerated: %s (UTC)\n\n" "$(date -u '+%Y-%m-%dT%H:%M:%SZ')" >"$REPORT_FILE"

    # currently active bans (always use sudo)
    {
        printf "--- CURRENTLY ACTIVE BANS ---\n"
        if sudo fail2ban-client status >/dev/null 2>&1; then
            local raw_jails j jlist banned_ips
            raw_jails="$(sudo fail2ban-client status 2>/dev/null |
                sed -n 's/.*Jail list:[[:space:]]*//p' |
                tr '\t' ' ' |
                sed 's/,/ /g; s/^[[:space:]]*//; s/[[:space:]]*$//' |
                tr -s ' ' |
                tr ' ' '\n')"

            if [[ -z "$raw_jails" ]]; then
                echo "(No active jails found)"
            else
                jlist="$(echo "$raw_jails" | tr ',' ' ' | xargs)"
                for j in $jlist; do
                    printf "\nJail: %s\n" "$j"
                    banned_ips="$(sudo fail2ban-client status "$j" 2>/dev/null |
                        sed -n 's/.*Banned IP list:[[:space:]]*//p' |
                        tr '\t' ' ' |
                        sed 's/,/ /g; s/^[[:space:]]*//; s/[[:space:]]*$//' |
                        tr -s ' ' |
                        tr ' ' '\n')"

                    if [[ -z "$banned_ips" ]]; then
                        echo "  (No IPs currently banned)"
                    else
                        echo "$banned_ips" | tr ' ' '\n' | sed 's/^/  /'
                    fi
                done
            fi
        else
            echo "(fail2ban-client not installed or cannot be run via sudo)"
        fi
        printf "\n"
    } >>"$REPORT_FILE"

    # historical bans from logs (use sudo zgrep or sudo grep)
    {
        printf "--- HISTORICAL BANS (from fail2ban logs) ---\n" >>"$REPORT_FILE"

        if ls /var/log/fail2ban.log* >/dev/null 2>&1; then
            IPS=$(sudo grep -h --text -- 'Ban ' /var/log/fail2ban.log* 2>/dev/null |
                awk '
            match($0, /Ban[[:space:]]+([0-9]{1,3}(\.[0-9]{1,3}){3})/, m) {
                ip = m[1]
                ts = $1 " " $2
                printf "  %-20s  %s\n", ts, ip
                ips[ip] = 1
            }
            END {
                count = 0
                for (ip in ips) count++
                if (count > 0) printf "\nTotal unique IPs historically banned: %d\n", count
                else print "  (no 'Ban' entries found in fail2ban logs)"
            }
        ')

            RECENT_10=$(echo "$IPS" | awk '
    /^[[:space:]]*[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}/ {
        ts = $1 " " $2
        ip = $3
        if (!(ip in seen) || ts > seen[ip]) {
            seen[ip] = ts
            lines[ip] = $0
        }
    }
    END {
        if (length(seen) == 0) {
            print "  (no '\''Ban'\'' entries found)"
            exit
        }
        # Sort IPs by latest timestamp
        n = 0
        for (ip in seen) {
            order[++n] = ip
        }
        # Simple bubble sort by timestamp (descending)
        for (i = 1; i <= n; i++) {
            for (j = i + 1; j <= n; j++) {
                if (seen[order[i]] < seen[order[j]]) {
                    temp = order[i]; order[i] = order[j]; order[j] = temp
                }
            }
        }
        printf "\n10 most recent banned IPs:\n"
        for (i = 1; i <= n && i <= 10; i++) {
            print lines[order[i]]
        }
    }')
            echo "$IPS" >>"$IP_REPORT_FILE"
            echo "$RECENT_10" >>"$REPORT_FILE"
        else
            echo "  No fail2ban log files found" >>"$REPORT_FILE"
        fi
    }

    # iptables / nftables snapshots (via sudo)
    {
        printf "\n--- IPS IN IPTABLES (sample) ---\n"
        if command -v iptables-save >/dev/null 2>&1; then
            sudo iptables-save 2>/dev/null | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' | sort -u | sed 's/^/  /' | head -n 50
        else
            echo "  iptables-save not present"
        fi

        printf "\n--- IPS IN NFTABLES (sample) ---\n"
        if command -v nft >/dev/null 2>&1; then
            sudo nft list ruleset 2>/dev/null | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' | sort -u | sed 's/^/  /' | head -n 50
        else
            echo "  nftables not present"
        fi
    } >>"$REPORT_FILE"

    echo "Report saved to: $REPORT_FILE"
    echo "IP report saved to : $IP_REPORT_FILE"
}

vm_init() {
    # creates a virtual machine with libvirt (uses ubuntu 24.04 as base image for now)

    NAME=${1:-ubuntu_vm}
    VM_IMG=${2:-"https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-amd64.img"}
    CLEAN_VM=${3:-1}
    IMG="/var/lib/libvirt/images/${NAME}.qcow2"
    CLOUD_DIR="/var/lib/libvirt/cloud-init"
    CLOUD_ISO="${CLOUD_DIR}/cidata.iso"
    BASE_IMG="/var/lib/libvirt/images/ubuntu2404-base.qcow2"

    # 1. clean old VM (if any)

    if [ "$CLEAN_VM" = "1" ]; then
        echo "Destroying old VMs..."
        sudo virsh destroy "$NAME" 2>/dev/null || true
        sudo virsh undefine "$NAME" --remove-all-storage 2>/dev/null || true
        sudo rm -rf "$CLOUD_DIR" "$IMG"
    fi

    # 2. download base cloud image

    if [ ! -f "$BASE_IMG" ]; then
        echo "Downloading Ubuntu 24.04 cloud image..."
        sudo wget -qO "$BASE_IMG" \
            https://cloud-images.ubuntu.com/noble/current/noble-server-cloudimg-amd64.img
    fi

    # 3. create cloud‑init files

    sudo mkdir -p "$CLOUD_DIR"

    # ---- meta-data (space-safe) ----
    printf '%s\n' \
        '#cloud-config' \
        "hostname: $NAME" \
        "fqdn: $NAME.local" \
        'users:' \
        '  - name: ubuntu' \
        '    sudo: ALL=(ALL) NOPASSWD:ALL' \
        '    plain_text_passwd: ubuntu123' \
        '    lock_passwd: false' \
        '    shell: /bin/bash' \
        'chpasswd: { expire: false }' \
        'ssh_pwauth: true' \
        'packages:' \
        '  - openssh-server' |
        sudo tee "${CLOUD_DIR}/user-data" >/dev/null

    # ---- user-data ----
    printf '%s\n' \
        "instance-id: $NAME" \
        "local-hostname: $NAME" |
        sudo tee "${CLOUD_DIR}/meta-data" >/dev/null

    # 4. build cidata ISO
    sudo apt-get install -y genisoimage
    sudo genisoimage -output "$CLOUD_ISO" -volid cidata -joliet -rock \
        "${CLOUD_DIR}/user-data" "${CLOUD_DIR}/meta-data"

    # 5. QCOW2 overlay disk
    sudo qemu-img create -f qcow2 -F qcow2 -b "$BASE_IMG" "$IMG" 20G

    # 6. start VM with sudo virt-install

    sudo virt-install \
        --name "$NAME" \
        --memory 3072 \
        --vcpus 2 \
        --disk path="$IMG",format=qcow2,bus=virtio,cache=none \
        --disk "$CLOUD_ISO",device=cdrom \
        --os-variant ubuntu24.04 \
        --network network=default,model=virtio \
        --graphics none \
        --import \
        --noautoconsole

    # 7. get VM's IP (max 90 s)

    MAC=$(sudo virsh dumpxml "$NAME" | grep -o "mac address='[^']*" | cut -d"'" -f2 | tr '[:upper:]' '[:lower:]')
    echo "MAC address: $MAC"
    echo "Waiting for IP (max 90 s)..."

    for i in $(seq 1 90); do
        IP=$(arp -an | grep -i "$MAC" | awk '{print $2}' | tr -d '()' || true)
        [ -n "$IP" ] && break
        sleep 1
    done

    if [ -z "$IP" ]; then
        echo "ERROR: No IP after 90 s"
        echo "Debug:"
        sudo virsh domblklist "$NAME"
        echo "Try: sudo virsh console $NAME  (Ctrl+] to exit)"
        exit 1
    fi

    echo "IP found: $IP"
    echo "SSH command: ssh ubuntu@$IP   (password: ubuntu123)"

}
