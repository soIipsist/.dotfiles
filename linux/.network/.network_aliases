export DUMPS_DIR="$HOME/.dumps"

ssh_dump() {
    local interface="${1:-any}"
    local dumps_filename="${2:-ssh_dump.pcap}"
    local outfile_path="$DUMPS_DIR/$dumps_filename"

    mkdir -p "$DUMPS_DIR"

    sudo tcpdump -i "$interface" -w "$outfile_path" -v '(tcp port 22 or tcp port 2222) and tcp[tcpflags] & tcp-syn != 0'
}

bruteforce_report() {
    local SAMPLE="${1:-5}"
    local TOPN="${2:-50}"
    local LOG="/var/log/auth.log"
    local PATTERN='failed password|invalid user|authentication failure|pam:|invalid login|connection reset|did not receive identification|refused connect|authentication error|illegal user'
    local ip_re='([0-9]{1,3}\.){3}[0-9]{1,3}'

    # temp files
    local tmp counts report
    tmp="$(mktemp)" || {
        echo "mktemp failed"
        return 1
    }
    counts="$(mktemp)" || {
        rm -f "$tmp"
        echo "mktemp failed"
        return 1
    }
    report="$(mktemp)" || {
        rm -f "$tmp" "$counts"
        echo "mktemp failed"
        return 1
    }

    # cleanup when function exits
    trap 'rm -f "$tmp" "$counts" "$report"' EXIT

    if [[ ! -r "$LOG" ]]; then
        echo "Cannot read $LOG. Run as root (sudo) or check file path." >&2
        return 1
    fi

    # collect matching lines (case-insensitive)
    grep -Ei "$PATTERN" "$LOG" >"$tmp" 2>/dev/null || true
    if [[ ! -s "$tmp" ]]; then
        echo "No matching failed-auth lines found in $LOG."
        return 0
    fi

    # produce sorted ip counts: "count ip"
    grep -Eo "$ip_re" "$tmp" | sort | uniq -c | sort -nr >"$counts"

    # report header
    {
        printf "BRUTE-FORCE / FAILED-AUTH SUMMARY\n"
        printf "Log: %s\nReport generated: %s\n\n" "$LOG" "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        printf "%-17s %8s  %-20s  %-20s  %s\n" "IP" "ATTEMPTS" "FIRST_LINE" "LAST_LINE" "USERS"
        printf "%s\n" "----------------------------------------------------------------------------------------------------------------"
    } >"$report"

    # print table rows (shell loop for portability)
    local line ip count printed=0 first_line last_line users f l
    while read -r count ip; do
        printed=$((printed + 1))
        if ((printed > TOPN)); then break; fi

        first_line="$(grep -F -- "$ip" "$tmp" | head -n1 || true)"
        last_line="$(grep -F -- "$ip" "$tmp" | tail -n1 || true)"

        # extract candidate usernames: look for 'for invalid user <user>' or 'for <user>'
        users="$(grep -F -- "$ip" "$tmp" |
            awk '{
          for(i=1;i<=NF;i++){
            if (tolower($i)=="for" && (i+1)<=NF) print $(i+1)
            if (tolower($i)=="user" && (i+1)<=NF) print $(i+1)
          }
        }' |
            sed 's/[:,;]$//' |
            sort -u |
            paste -s -d, - 2>/dev/null || true)"

        if [[ -z "$users" ]]; then users="-"; fi

        # truncate first/last for table clarity (20 chars)
        if [[ ${#first_line} -gt 20 ]]; then f="${first_line:0:17}..."; else f="$first_line"; fi
        if [[ ${#last_line} -gt 20 ]]; then l="${last_line:0:17}..."; else l="$last_line"; fi

        printf "%-17s %8s  %-20s  %-20s  %s\n" "$ip" "$count" "$f" "$l" "$users" >>"$report"
    done <"$counts"

    # lines without IPv4
    local noip_count
    noip_count=$(grep -Eiv "$ip_re" "$tmp" | wc -l | tr -d '[:space:]')
    if [[ "$noip_count" -gt 0 ]]; then
        printf "\n%-17s %8s  %s\n" "NO_IP" "$noip_count" "(lines without an IPv4 address)" >>"$report"
    fi

    # sample lines header
    {
        printf "\n\nSAMPLE LINES (up to %d per IP) â€” top IPs first\n" "$SAMPLE"
        printf "%s\n" "--------------------------------------------------------------------"
    } >>"$report"

    # append sample lines for top IPs
    printed=0
    while read -r _ ip; do
        printed=$((printed + 1))
        if ((printed > TOPN)); then break; fi
        printf "\n--- %s ---\n" "$ip" >>"$report"
        grep -F -- "$ip" "$tmp" | head -n "$SAMPLE" >>"$report"
    done <"$counts"

    # include some NO_IP lines if present
    if [[ "$noip_count" -gt 0 ]]; then
        {
            printf "\n\n--- LINES WITHOUT AN IPv4 (first 30 shown) ---\n"
            grep -Eiv "$ip_re" "$tmp" | head -n 30
        } >>"$report"
    fi

    less -R "$report"
}
