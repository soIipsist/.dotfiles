export TCPDUMP_DIR="$HOME/.tcpdump"
export UID="${UID:-$(id -u 2>/dev/null || echo 1000)}"
export REPORT_DIR="/tmp/$UID/reports"
export SCAN_METHOD="clamscan"

whereami() {
    local target_ip="${1:-$(curl -4s https://ifconfig.co)}"
    curl -s "https://ipinfo.io/${target_ip}/json" | jq "{ip, city, region, country, org, loc, timezone}"
}

get_private_ip() {
    ip route get 1.1.1.1 2>/dev/null | awk '
        { for (i=1;i<=NF;i++) if ($i=="src") { print $(i+1); exit } }
    '
}

ssh_dump() {
    local interface="${1:-any}"
    local dumps_filename="${2:-ssh_dump.pcap}"
    local outfile_path="$TCPDUMP_DIR/$dumps_filename"
    mkdir -p "$TCPDUMP_DIR"
    sudo tcpdump -i "$interface" -w "$outfile_path" -v '(tcp port 22 or tcp port 2222) and tcp[tcpflags] & tcp-syn != 0'
}

report_bruteforce() {
    local SAMPLE="${1:-5}"
    local TOPN="${2:-50}"
    local LOG="/var/log/auth.log"
    local REPORT_FILE="$REPORT_DIR/bruteforce_report_$(date -u '+%Y-%m-%dT%H-%M-%SZ').log"
    local PATTERN='failed password|invalid user|authentication failure|pam:|invalid login|connection reset|did not receive identification|refused connect|authentication error|illegal user'
    local ip_re='([0-9]{1,3}\.){3}[0-9]{1,3}'

    mkdir -p "$REPORT_DIR"

    # temp files
    local tmp counts
    tmp="$(mktemp)" || {
        echo "mktemp failed"
        return 1
    }
    counts="$(mktemp)" || {
        rm -f "$tmp"
        echo "mktemp failed"
        return 1
    }

    # cleanup when function exits
    trap 'rm -f "$tmp" "$counts"' EXIT

    if [[ ! -r "$LOG" ]]; then
        echo "Cannot read $LOG. Run as root (sudo) or check file path." >&2
        return 1
    fi

    # collect matching lines (case-insensitive)
    grep -Ei "$PATTERN" "$LOG" >"$tmp" 2>/dev/null || true
    if [[ ! -s "$tmp" ]]; then
        echo "No matching failed-auth lines found in $LOG."
        return 0
    fi

    # produce sorted ip counts: "count ip"
    grep -Eo "$ip_re" "$tmp" | sort | uniq -c | sort -nr >"$counts"

    # report header
    {
        printf "BRUTE-FORCE / FAILED-AUTH SUMMARY\n"
        printf "Log: %s\nReport generated: %s\n\n" "$LOG" "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        printf "%-17s %8s  %-20s  %-20s  %s\n" "IP" "ATTEMPTS" "FIRST_LINE" "LAST_LINE" "USERS"
        printf "%s\n" "----------------------------------------------------------------------------------------------------------------"
    } >"$REPORT_FILE"

    # print table rows (shell loop for portability)
    local line ip count printed=0 first_line last_line users f l
    while read -r count ip; do
        printed=$((printed + 1))
        if ((printed > TOPN)); then break; fi

        first_line="$(grep -F -- "$ip" "$tmp" | head -n1 || true)"
        last_line="$(grep -F -- "$ip" "$tmp" | tail -n1 || true)"

        # extract candidate usernames: look for 'for invalid user <user>' or 'for <user>'
        users="$(grep -F -- "$ip" "$tmp" |
            awk '{
          for(i=1;i<=NF;i++){
            if (tolower($i)=="for" && (i+1)<=NF) print $(i+1)
            if (tolower($i)=="user" && (i+1)<=NF) print $(i+1)
          }
        }' |
            sed 's/[:,;]$//' |
            sort -u |
            paste -s -d, - 2>/dev/null || true)"

        if [[ -z "$users" ]]; then users="-"; fi

        # truncate first/last for table clarity (20 chars)
        if [[ ${#first_line} -gt 20 ]]; then f="${first_line:0:17}..."; else f="$first_line"; fi
        if [[ ${#last_line} -gt 20 ]]; then l="${last_line:0:17}..."; else l="$last_line"; fi

        printf "%-17s %8s  %-20s  %-20s  %s\n" "$ip" "$count" "$f" "$l" "$users" >>"$REPORT_FILE"
    done <"$counts"

    # lines without IPv4
    local noip_count
    noip_count=$(grep -Eiv "$ip_re" "$tmp" | wc -l | tr -d '[:space:]')
    if [[ "$noip_count" -gt 0 ]]; then
        printf "\n%-17s %8s  %s\n" "NO_IP" "$noip_count" "(lines without an IPv4 address)" >>"$REPORT_FILE"
    fi

    # sample lines header
    {
        printf "\n\nSAMPLE LINES (up to %d per IP) â€” top IPs first\n" "$SAMPLE"
        printf "%s\n" "--------------------------------------------------------------------"
    } >>"$REPORT_FILE"

    # append sample lines for top IPs
    printed=0
    while read -r _ ip; do
        printed=$((printed + 1))
        if ((printed > TOPN)); then break; fi
        printf "\n--- %s ---\n" "$ip" >>"$REPORT_FILE"
        grep -F -- "$ip" "$tmp" | head -n "$SAMPLE" >>"$REPORT_FILE"
    done <"$counts"

    # include some NO_IP lines if present
    if [[ "$noip_count" -gt 0 ]]; then

        printf "\n\n--- LINES WITHOUT AN IPv4 (first 30 shown) ---\n" >>"$REPORT_FILE"
        grep -Eiv "$ip_re" "$tmp" | head -n 30 >>"$REPORT_FILE"
    fi
    echo "Report saved to: $REPORT_FILE"
}

report_fail2ban() {
    local REPORT_FILE
    local TMP_CURR

    mkdir -p "$REPORT_DIR"
    REPORT_FILE="$REPORT_DIR/fail2ban_report_$(date -u '+%Y-%m-%dT%H-%M-%SZ').log"
    IP_REPORT_FILE="$REPORT_DIR/fail2ban_ip_report_$(date -u '+%Y-%m-%dT%H-%M-%SZ').log"

    # temp files
    TMP_CURR="$(mktemp)" || return 1
    trap 'rm -f "$TMP_CURR"' EXIT

    # report header
    printf "FAIL2BAN REPORT\nGenerated: %s (UTC)\n\n" "$(date -u '+%Y-%m-%dT%H:%M:%SZ')" >"$REPORT_FILE"

    # currently active bans (always use sudo)
    {
        printf "--- CURRENTLY ACTIVE BANS ---\n"
        if sudo fail2ban-client status >/dev/null 2>&1; then
            local raw_jails j jlist banned_ips
            raw_jails="$(sudo fail2ban-client status 2>/dev/null |
                sed -n 's/.*Jail list:[[:space:]]*//p' |
                tr '\t' ' ' |
                sed 's/,/ /g; s/^[[:space:]]*//; s/[[:space:]]*$//' |
                tr -s ' ' |
                tr ' ' '\n')"

            if [[ -z "$raw_jails" ]]; then
                echo "(No active jails found)"
            else
                jlist="$(echo "$raw_jails" | tr ',' ' ' | xargs)"
                for j in $jlist; do
                    printf "\nJail: %s\n" "$j"
                    banned_ips="$(sudo fail2ban-client status "$j" 2>/dev/null |
                        sed -n 's/.*Banned IP list:[[:space:]]*//p' |
                        tr '\t' ' ' |
                        sed 's/,/ /g; s/^[[:space:]]*//; s/[[:space:]]*$//' |
                        tr -s ' ' |
                        tr ' ' '\n')"

                    if [[ -z "$banned_ips" ]]; then
                        echo "  (No IPs currently banned)"
                    else
                        echo "$banned_ips" | tr ' ' '\n' | sed 's/^/  /'
                    fi
                done
            fi
        else
            echo "(fail2ban-client not installed or cannot be run via sudo)"
        fi
        printf "\n"
    } >>"$REPORT_FILE"

    # historical bans from logs (use sudo zgrep or sudo grep)
    {
        printf "--- HISTORICAL BANS (from fail2ban logs) ---\n" >>"$REPORT_FILE"

        if ls /var/log/fail2ban.log* >/dev/null 2>&1; then
            IPS=$(sudo grep -h --text -- 'Ban ' /var/log/fail2ban.log* 2>/dev/null |
                awk '
            match($0, /Ban[[:space:]]+([0-9]{1,3}(\.[0-9]{1,3}){3})/, m) {
                ip = m[1]
                ts = $1 " " $2
                printf "  %-20s  %s\n", ts, ip
                ips[ip] = 1
            }
            END {
                count = 0
                for (ip in ips) count++
                if (count > 0) printf "\nTotal unique IPs historically banned: %d\n", count
                else print "  (no 'Ban' entries found in fail2ban logs)"
            }
        ')

            RECENT_10=$(echo "$IPS" | awk '
    /^[[:space:]]*[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}/ {
        ts = $1 " " $2
        ip = $3
        if (!(ip in seen) || ts > seen[ip]) {
            seen[ip] = ts
            lines[ip] = $0
        }
    }
    END {
        if (length(seen) == 0) {
            print "  (no '\''Ban'\'' entries found)"
            exit
        }
        # Sort IPs by latest timestamp
        n = 0
        for (ip in seen) {
            order[++n] = ip
        }
        # Simple bubble sort by timestamp (descending)
        for (i = 1; i <= n; i++) {
            for (j = i + 1; j <= n; j++) {
                if (seen[order[i]] < seen[order[j]]) {
                    temp = order[i]; order[i] = order[j]; order[j] = temp
                }
            }
        }
        printf "\n10 most recent banned IPs:\n"
        for (i = 1; i <= n && i <= 10; i++) {
            print lines[order[i]]
        }
    }')
            echo "$IPS" >>"$IP_REPORT_FILE"
            echo "$RECENT_10" >>"$REPORT_FILE"
        else
            echo "  No fail2ban log files found" >>"$REPORT_FILE"
        fi
    }

    # iptables / nftables snapshots (via sudo)
    {
        printf "\n--- IPS IN IPTABLES (sample) ---\n"
        if command -v iptables-save >/dev/null 2>&1; then
            sudo iptables-save 2>/dev/null | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' | sort -u | sed 's/^/  /' | head -n 50
        else
            echo "  iptables-save not present"
        fi

        printf "\n--- IPS IN NFTABLES (sample) ---\n"
        if command -v nft >/dev/null 2>&1; then
            sudo nft list ruleset 2>/dev/null | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' | sort -u | sed 's/^/  /' | head -n 50
        else
            echo "  nftables not present"
        fi
    } >>"$REPORT_FILE"

    echo "Report saved to: $REPORT_FILE"
    echo "IP report saved to : $IP_REPORT_FILE"
}

report_ssh() {
    local output
    local REPORT_FILE="$REPORT_DIR/ssh_auth_$(date -u '+%Y-%m-%dT%H-%M-%SZ').log"

    if command -v journalctl >/dev/null 2>&1; then
        output=$(journalctl _COMM=sshd | grep "Accepted password\|Accepted publickey" |
            awk '{for(i=1;i<=NF;i++){if($i=="from"){print $(i+1)}}}' |
            sort | uniq -c | sort -nr | awk '{printf "%s connections from %s\n",$1,$2}')
    else
        LOG_FILE="/var/log/auth.log"
        [ -f /var/log/secure ] && LOG_FILE="/var/log/secure"

        output=$(grep "Accepted password\|Accepted publickey" "$LOG_FILE" |
            awk '{for(i=1;i<=NF;i++){if($i=="from"){print $(i+1)}}}' |
            sort | uniq -c | sort -nr | awk '{printf "%s connections from %s\n",$1,$2}')
    fi

    echo "Report saved to: $REPORT_FILE"
    echo "$output" >>"$REPORT_FILE"
}

scan_files() {
    method="${SCAN_METHOD:-clamscan}"
    files=()

    while (("$#")); do
        case "$1" in
        --method)
            method="$2"
            shift 2
            ;;
        --method=*)
            method="${1#--method=}"
            shift
            ;;
        *)
            files+=("$1")
            shift
            ;;
        esac
    done

    if [[ $method == "vt" ]]; then
        # expand directories into files
        expanded_files=()
        for input in "${files[@]}"; do
            if [[ -d "$input" ]]; then
                for f in "$input"/*; do
                    [[ -f "$f" ]] && expanded_files+=("$f")
                done
            else
                expanded_files+=("$input")
            fi
        done
        files=("${expanded_files[@]}")
    fi

    log_dir="${HOME:-$REPORT_DIR}"
    log_path="$REPORT_DIR/${method}_$(date -u '+%Y-%m-%dT%H-%M-%SZ').log"

    [[ ${#files[@]} -eq 0 ]] && {
        echo "No valid files to scan."
        return 1
    }

    for file in "${files[@]}"; do
        echo "=== Scanning: $file ==="

        case "$method" in
        clamscan)
            echo "[method=clamscan]"
            clamscan "$file" --log="$log_path"
            ;;
        vt)
            echo "[method=vt]"

            file_id=$(vt scan file "$file" | awk '{print $2}')
            echo "$file -> $file_id" >>"$log_path"

            (
                while true; do
                    analysis=$(vt analysis "$file_id")
                    vt_status=$(echo "$analysis" | grep -i 'status' | awk -F': ' '{print $2}' | tr -d '[:space:]')
                    if [[ "$vt_status" != "queued" ]]; then
                        echo "$file analysis ready:" >>"$log_path"
                        echo "$analysis" >>"$log_path"
                        break
                    fi
                    sleep 10
                done
            ) &
            ;;
        mediainfo | *)
            echo "[method=mediainfo]"
            mediainfo "$file" --LogFile="$log_path"
            ;;
        esac
        echo
    done
    wait
}
